# Cheaters

## Условие

Я никогда не списывал. Поверили? И правильно. Вот и наш препод по философии нам не верит, САМ написал сайт, где теперь наши тесты проверяет, да еще и смотрит, списываем мы или нет.
[Сайт](http://web3.tasks.tulactf.ru/)

Формат флага: `TulaCTF{some_flag}`

## Решение

Залогиниться на сайте можно было с любой комбинацией логина и пароля, после чего выдавалась cookie **"token"**, представлюящий собой **jwt**-токен.

Раскодировав токен на [jwt.io](https://jwt.io), поймем, что в разделе **payload** есть поле **admin**. Однако любые манипуляции с алгоритмами и перебор секрета бесполезны. ~~Таск не решаем, можем расходиться~~.

Изучив исходный кол программы, а точнее, функцию **checkForCheaters**, заметим, что происходит парсинг **xml**-схемы из **docProp/core.xml** (лежит внутри отправляемого файла, т.к. **xlsx** файл по сути является **zip** архивом), в которой содержатся поля с создателем и пользователем, последним изменившим файл.

Т.к. при загрузке файла с разными полями возвращалась страница с именем *"списавшего"* пользователя, можно с помощью внедрения ENTITY в файле **docProp/core.xml** изменить имя пользователя, последним изменившего файл, на любое значение, в том числе на содержимое любого файда (спасибо удачно выставленым настройкам парсера).

Таким способом выведем содержимое файла **app.py**, в котором задан **secret_key**, используемый во **Flask** для подписи **jwt**-токена.

Подпишем кастомный токен с полем **admin**, равным **True**, подменим cookie и от лица админа получим флаг.
 