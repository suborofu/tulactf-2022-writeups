# Overpowered

## Условие

Думал, тут будет какая-то загадка? Увы, но нет. Надо просто сделать так, чтобы следующий скрипт отработал правильно.

```python
n = 174881424808790868060849111589994136416819045808641836889686910917688352667961
c = 39523780285962116273620763153889999362608558862573792084872798679396455703616
p0 = 78935931461844488658469152242414193366493910650126758265671774994856253142403
p1 = 78555126861852380729363352598223836665687549887221862399793758165974225343280
print(pow(c, pow(p0, p1), n).to_bytes(32, 'big'))
```

Ничего сложного, правда ведь?

Формат флага: `TulaCTF{some_flag}`

## Решение

Если запустить скрипт, скорее всего, соревнование закончится быстрее, чем он выполнится. Проблема в `pow(p0, p1)` - это очень большое число, гораздо больше `n`. По теореме Эйлера имеем:

```python
d = p0**p1 % phi(n)
или
d = pow(p0, p1, phi(n))
```

Вычислить `d` по модулю несравненно быстрее. Удручает, что мы не знаем `phi(n)`. Но... внезапно, если посмотреть, `n` - простое число. Это дает нам:

```python
phi(n) == n-1
```

Тогда решение будет выглядеть, например, вот так:

```python
print(pow(c, pow(p0, p1, n-1), n).to_bytes(32, 'big'))
```
